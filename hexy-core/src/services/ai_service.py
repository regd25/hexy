"""
AI Service for generating semantic relation suggestions
"""

from typing import Dict, Any, Optional
import openai
from pydantic import BaseModel
import structlog

logger = structlog.get_logger(__name__)


class SemanticRelationRequest(BaseModel):
    sourceNode: Dict[str, Any]
    targetNode: Dict[str, Any]
    relationType: str
    prompt: Optional[str] = None


class SemanticRelationResponse(BaseModel):
    suggestion: str
    confidence: float
    reasoning: str


class AIService:
    """
    Service for generating AI suggestions for semantic relations
    """

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        if api_key:
            openai.api_key = api_key

    def generate_semantic_suggestion(
        self,
        source_node: Dict[str, Any],
        target_node: Dict[str, Any],
        relation_type: str,
    ) -> SemanticRelationResponse:
        """
        Generates an AI suggestion for a semantic relation

        Args:
            source_node: Source node
            target_node: Target node
            relation_type: Type of relation

        Returns:
            Response with the generated suggestion
        """
        try:
            prompt = self._build_prompt(source_node, target_node, relation_type)

            if not self.api_key:
                return self._generate_fallback_suggestion(
                    source_node, target_node, relation_type
                )

            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {
                        "role": "system",
                        "content": "Eres un experto en modelado semÃ¡ntico organizacional y el framework Hexy. Tu tarea es generar justificaciones coherentes para relaciones entre artefactos organizacionales.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=200,
                temperature=0.7,
            )

            suggestion = response.choices[0].message.content.strip()

            return SemanticRelationResponse(
                suggestion=suggestion,
                confidence=0.85,
                reasoning="Generated by AI using semantic analysis of artifacts",
            )

        except Exception as e:
            logger.error("Error generating AI suggestion", error=str(e))
            return self._generate_fallback_suggestion(
                source_node, target_node, relation_type
            )

    def _build_prompt(
        self,
        source_node: Dict[str, Any],
        target_node: Dict[str, Any],
        relation_type: str,
    ) -> str:
        """
        Builds the prompt for the AI

        Args:
            source_node: Source node
            target_node: Target node
            relation_type: Type of relation

        Returns:
            Built prompt
        """
        return f"""
        Analyze the semantic relationship between these two organizational artifacts from the Hexy Framework:

        **Source Artifact:**
        - Name: {source_node.get('name', 'N/A')}
        - Type: {source_node.get('type', 'N/A')}
        - Description: {source_node.get('info', 'N/A')}

        **Target Artifact:**
        - Name: {target_node.get('name', 'N/A')}
        - Type: {target_node.get('type', 'N/A')}
        - Description: {target_node.get('info', 'N/A')}

        **Relationship Type:** {relation_type}

        Generate a coherent semantic justification that explains:

        1. **Why this relationship exists** - The logical reason behind the connection
        2. **How it contributes to the organizational context** - The value it brings to the system
        3. **What impact it has on business logic** - How it affects operations

        The response should be:
        - Clear and specific
        - Aligned with Hexy Framework principles
        - Focused on organizational context
        - Maximum 150 words

        Respond only with the justification, without introductions or additional explanations.
        """

    def _generate_fallback_suggestion(
        self,
        source_node: Dict[str, Any],
        target_node: Dict[str, Any],
        relation_type: str,
    ) -> SemanticRelationResponse:
        """
        Generates a fallback suggestion when AI is not available

        Args:
            source_node: Source node
            target_node: Target node
            relation_type: Type of relation

        Returns:
            Fallback suggestion
        """
        source_name = source_node.get("name", "Source Artifact")
        target_name = target_node.get("name", "Target Artifact")

        suggestions = {
            "uses": f'The artifact "{source_name}" uses "{target_name}" as a fundamental component for its operation, establishing an operational dependency that strengthens the coherence of the organizational context.',
            "implements": f'The artifact "{source_name}" implements the guidelines defined in "{target_name}", ensuring that operations align with established organizational principles.',
            "supports": f'The artifact "{source_name}" provides direct support to "{target_name}", facilitating its execution and contributing to the achievement of organizational objectives.',
            "defines": f'The artifact "{source_name}" defines the parameters and conditions that govern "{target_name}", establishing the reference framework for its application in the organizational context.',
            "triggers": f'The artifact "{source_name}" acts as a catalyst that triggers the activation of "{target_name}", creating a chain of events that optimizes organizational workflow.',
            "validates": f'The artifact "{source_name}" validates the compliance and quality of "{target_name}", ensuring it meets the standards and expectations of the organizational context.',
        }

        suggestion = suggestions.get(
            relation_type,
            f'The artifact "{source_name}" relates to "{target_name}" through the "{relation_type}" connection, establishing a semantic linkage that strengthens the coherence of the organizational context.',
        )

        return SemanticRelationResponse(
            suggestion=suggestion,
            confidence=0.6,
            reasoning="Generated using predefined rules (AI not available)",
        )

    def validate_semantic_relation(
        self,
        source_node: Dict[str, Any],
        target_node: Dict[str, Any],
        relation_type: str,
    ) -> Dict[str, Any]:
        """
        Validates a semantic relation

        Args:
            source_node: Source node
            target_node: Target node
            relation_type: Type of relation

        Returns:
            Validation result
        """
        validations = {"isValid": True, "errors": [], "warnings": []}

        if source_node.get("id") == target_node.get("id"):
            validations["isValid"] = False
            validations["errors"].append("Cannot create a relationship with itself")

        if not relation_type or relation_type.strip() == "":
            validations["isValid"] = False
            validations["errors"].append("Relationship type is required")

        hierarchical_rules = self._check_hierarchical_rules(
            source_node, target_node, relation_type
        )
        if not hierarchical_rules["isValid"]:
            validations["warnings"].append(hierarchical_rules["message"])

        return validations

    def _check_hierarchical_rules(
        self,
        source_node: Dict[str, Any],
        target_node: Dict[str, Any],
        relation_type: str,
    ) -> Dict[str, Any]:
        """
        Checks hierarchical rules between artifacts

        Args:
            source_node: Source node
            target_node: Target node
            relation_type: Type of relation

        Returns:
            Hierarchical validation result
        """
        hierarchy = {
            "purpose": 1,
            "vision": 2,
            "policy": 3,
            "principle": 4,
            "guideline": 5,
            "context": 6,
            "actor": 7,
            "concept": 8,
            "process": 9,
            "procedure": 10,
            "event": 11,
            "result": 12,
            "observation": 13,
            "evaluation": 14,
            "indicator": 15,
            "area": 16,
        }

        source_type = source_node.get("type", "")
        target_type = target_node.get("type", "")

        source_level = hierarchy.get(source_type, 999)
        target_level = hierarchy.get(target_type, 999)

        if source_level > target_level and relation_type in ["defines", "implements"]:
            return {
                "isValid": False,
                "message": f"A {source_type} cannot define or implement a {target_type} of higher level",
            }

        if source_level < target_level and relation_type in ["uses", "depends_on"]:
            return {
                "isValid": False,
                "message": f"A {source_type} of higher level should not depend on a {target_type} of lower level",
            }

        return {"isValid": True}
